//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан программой.
//     Исполняемая версия:4.0.30319.42000
//
//     Изменения в этом файле могут привести к неправильной работе и будут потеряны в случае
//     повторной генерации кода.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Curie
{
	public class CuriePlaceEmitter: ICurieEmitter
	{
		public enum PlaceEmitterType{
			Error,
			Center,
			SurfacePoint,
			SurfacePlane
		}
		public const string ConfigNodeName = "CuriePlaceEmitter";
		public const float UPDATE_RATE = 10; //in seconds
		public const float RAYCAST_RANGE = 100;
		public const float MIN_INTENSITY = 1;
		public const float STEP = 0.2f;
		Dictionary<Vessel,List<GameObject>> lines = new Dictionary<Vessel, List<GameObject>>();
		public string bodyName;
		public PlaceEmitterType type;
		public float intensity; // flow at 1m distance over STEP^2 area
		public float radius {get;private set;}
		float lastUpdate;
		CelestialBody body;
		List<MaterialColorUpdater> mcu = new List<MaterialColorUpdater>();

		public void FixedUpdate(){
			if(Time.time - lastUpdate > UPDATE_RATE)
			{
				lastUpdate = Time.time;
				Vector3 emitterPos = body.getTruePositionAtUT(HighLogic.CurrentGame.UniversalTime);
				foreach(var vessel in FlightGlobals.Vessels)
				{
					if((vessel.vesselType == VesselType.Flag) || 
					   (vessel.vesselType == VesselType.SpaceObject) || 
					   (vessel.vesselType == VesselType.Unknown))
						continue;
					Vector3d vesselPos = vessel.GetWorldPos3D();
					double dist = Vector3d.Distance(vesselPos,emitterPos);

					if(dist>radius)
						continue;

					VesselBounds(vessel);
				}
			}
/*			if(Time.time - lastUpdate > UPDATE_RATE)
			{
				lastUpdate = Time.time;
				Vector3 emitterPos = body.getTruePositionAtUT(HighLogic.CurrentGame.UniversalTime);
				Vector3 scBod = ScaledSpace.LocalToScaledSpace(emitterPos);
				this.Log(bodyName + " emitting in " + radius.ToString() + "m radius");
				//this.Log("Scaled coordinats = " + scBod.ToString());
				foreach(var vessel in FlightGlobals.Vessels)
				{
					if(lines.ContainsKey(vessel)){
						foreach(var g in lines[vessel])
							GameObject.Destroy(g);
					}
					lines[vessel] = new List<GameObject>();
					Vector3d vesselPos = vessel.GetWorldPos3D();

					double dist = Vector3d.Distance(vesselPos,emitterPos);

					if(dist>radius)
						continue;
					//this.Log(vessel.vesselName + " packed = " + vessel.pac
					if(!vessel.loaded)//TODO if not loaded - apply non physics calculations
						continue;
					//DebugRoot();
					//DebugUp(vessel.parts[0].transform);
					Part p_ = (Part)UnityEngine.Object.Instantiate (vessel.protoVessel.protoPartSnapshots[0].partInfo.partPrefab);
					p_.gameObject.SetActive(true);
					p_.transform.position = vessel.transform.position + new Vector3(3,0,0);

					Bounds bounds = CalculateCraftBounds(vessel);
					//Vector3 scVes = ScaledSpace.LocalToScaledSpace(vesselPos);

					Vector3 toVessel = vessel.vesselTransform.InverseTransformDirection(vesselPos-emitterPos);
					toVessel.Normalize();
					List<Vector3> tmp = new List<Vector3>(projectBound(bounds, toVessel));
					Vector3 bas1 = new Vector3(-toVessel.z/toVessel.x,0,1);
					bas1.Normalize();
					Vector3 bas2 = Vector3.Cross(toVessel,bas1);
					Vector2 min = new Vector2(10000,10000);
					Vector2 max = new Vector2(-10000,-10000);
					foreach(Vector3 v3 in tmp){
						Vector2 tmp2d = new Vector2(Vector3.Dot(v3,bas1),Vector3.Dot(v3,bas2));
						if(tmp2d.x < min.x)
							min.x = tmp2d.x;
						else if(tmp2d.x > max.x)
							max.x = tmp2d.x;
						if(tmp2d.y < min.y)
							min.y = tmp2d.y;
						else if(tmp2d.y > max.y)
							max.y = tmp2d.y;
					}
					var currPos = max - new Vector2(STEP, STEP);
					while(currPos.y>min.y){
						while(currPos.x>min.x){
							//this.Log("Ray at " + currPos);
							Vector3 currPos3D = vessel.vesselTransform.TransformPoint(currPos.x*bas1+currPos.y*bas2);
							Vector3 toVesselG = vessel.vesselTransform.TransformDirection(toVessel);
							Vector3[] tmp2 = new Vector3[2];
							//tmp2[0] = rayOrigin-toVessel*5;
							//tmp2[1] = rayOrigin+toVessel*5;
							RaycastHit[] hits = Physics.RaycastAll(currPos3D-RAYCAST_RANGE/2*toVesselG, toVesselG, RAYCAST_RANGE);
							RaycastHit[] invHits = Physics.RaycastAll(currPos3D+RAYCAST_RANGE/2*toVesselG, -toVesselG, RAYCAST_RANGE);
							CurieRay r = new CurieRay((float)(intensity/dist/dist),hits,invHits);
							string hitParts = "";
							foreach(RaycastHit hit in hits)
							{
								Part p = hit.transform.GetComponent<Part>();
								//if(p!=null)
								//	hitParts += p.partInfo.name + ",";
								hitParts += hit.transform.name + ",";
							}

							if(hitParts != ""){
								//hitParts.Remove(hitParts.Length-2);
							//	this.Log("\tParts hit (" + hitParts + ")");
							}
							lines[vessel].Add(addLine(tmp2,vessel.vesselTransform));
							currPos.x -= STEP;
						}
						currPos.x = max.x - STEP;
						currPos.y -= STEP;
					}
				}
			}*/
		}

		public static CuriePlaceEmitter Load(ConfigNode node)
		{
			CuriePlaceEmitter cpe = new CuriePlaceEmitter();
			cpe.bodyName = Utilities.GetValue(node,"bodyName","ERROR");
			cpe.type = Utilities.GetValue<PlaceEmitterType>(node,"type",PlaceEmitterType.Error);
			cpe.intensity = Utilities.GetValue(node,"intensity",1000f);
			cpe.radius = Mathf.Sqrt(cpe.intensity/MIN_INTENSITY);
			cpe.body = FlightGlobals.Bodies.Find(b=>b.bodyName == cpe.bodyName);
			return cpe;
		}

		GameObject addLine(Vector3[] points, Transform parent)
		{
			var line = new GameObject("Line");
			var lr = line.AddComponent<LineRenderer>();
			line.transform.SetParent(parent);
			line.transform.localPosition = Vector3.zero;
			line.transform.localRotation = Quaternion.identity;
			lr.material = new Material( Shader.Find( "Particles/Additive" ) );
			lr.SetVertexCount(points.GetLength(0));
			lr.useWorldSpace = false;
			lr.SetColors(Color.green,Color.green);
			lr.SetWidth(0.004f,0.004f);
			for(int i=0; i<points.GetLength(0); i++)
				lr.SetPosition(i,points[i]);
			return line;
		}

		public void Save(ConfigNode node)
		{
			var node_ = node.AddNode(ConfigNodeName);
			node_.AddValue("bodyName",bodyName);
			node_.AddValue("type",type);
			node_.AddValue("intensity",intensity);
		}

		void DebugUp(Transform t)
		{
			this.Log(t.name);
			if( t.parent != null )
				DebugUp(t.parent);
			else
				this.Log("\n");
		}
		void DebugRoot()
		{
			Debug.Log("----- Debug root -----");
			foreach (GameObject go in UnityEngine.Object.FindObjectsOfType(typeof(GameObject)))
			{
				if (go.transform.parent == null)
				{
					DebugDeeper(go.transform,1);
				}
			}
		}
		
		void DebugDeeper(Transform trans, int level)
		{
			int children = trans.GetChildCount();
			String prefix="";
			for(int i=0; i<level; i++)
				prefix += "\t";
			Debug.Log( prefix + trans.name);
			//Debug.Log( prefix + trans.name + " has " + children);
			
			for (int child=0;child<children;child++)
			{
				DebugDeeper( trans.GetChild(child), level+1 );
			}
		}

		Bounds VesselBounds(Vessel vessel)
		{
			Bounds bounds = default(Bounds);
			if(vessel.loaded)
			{
			//	vessel.protoVessel.protoPartSnapshots.ConvertAll( pps => {pps.partInfo.partPrefab.gameObject.SetActive(true);return true;});
				using(var enumerator = vessel.parts.GetEnumerator())
					while (enumerator.MoveNext())
					{
						Part p = enumerator.Current;
						var meshes = new List<MeshFilter>(p.FindModelComponents<MeshFilter>());
						foreach(MeshFilter mf in meshes){
							Vector3 min = mf.mesh.bounds.min, max = mf.mesh.bounds.max;
							min = vessel.vesselTransform.InverseTransformPoint(mf.transform.TransformPoint(min));
							max = vessel.vesselTransform.InverseTransformPoint(mf.transform.TransformPoint(max));
							bounds.Encapsulate(min);
							bounds.Encapsulate(max);
						}
				}
				//this.Log("vessel scale = " + vessel.vesselTransform.lossyScale);
				//this.Log("vessel Lscale = " + vessel.vesselTransform.localScale);
				this.Log("\t 1 min = " + bounds.min + ", max = " + bounds.max);
				this.Log("");
				//return bounds;
			}
			using(var e = vessel.protoVessel.protoPartSnapshots.GetEnumerator())
				while (e.MoveNext())
				{
					var pps = e.Current;
					var p = pps.partInfo.partPrefab;
					var meshes = new List<MeshFilter>(p.FindModelComponents<MeshFilter>());
					foreach(MeshFilter mf in meshes){
						Vector3 min = mf.mesh.bounds.min, max = mf.mesh.bounds.max;
						min = (mf.transform.TransformPoint(min));
						max = (mf.transform.TransformPoint(max));
						bounds.Encapsulate(min);
						bounds.Encapsulate(max);
					}
				}
				this.Log("\tmin = " + bounds.min + ", max = " + bounds.max);
				this.Log("");
				return bounds;
		}

		Vector3[] projectBound(Bounds b, Vector3 n){
			Vector3 v3Center = b.center;
			Vector3 v3Extents = b.extents;
			var projected = new Vector3[9];
			projected[0] = new Vector3(v3Center.x - v3Extents.x, v3Center.y + v3Extents.y, v3Center.z - v3Extents.z);
			projected[1] = new Vector3(v3Center.x + v3Extents.x, v3Center.y + v3Extents.y, v3Center.z - v3Extents.z);
			projected[2] = b.min;
			projected[3] = new Vector3(v3Center.x + v3Extents.x, v3Center.y - v3Extents.y, v3Center.z - v3Extents.z);
			projected[4] = new Vector3(v3Center.x - v3Extents.x, v3Center.y + v3Extents.y, v3Center.z + v3Extents.z);
			projected[5] = b.max;
			projected[6] = new Vector3(v3Center.x - v3Extents.x, v3Center.y - v3Extents.y, v3Center.z + v3Extents.z);
			projected[7] = new Vector3(v3Center.x + v3Extents.x, v3Center.y - v3Extents.y, v3Center.z + v3Extents.z);
			projected[8] = new Vector3(v3Center.x - v3Extents.x, v3Center.y + v3Extents.y, v3Center.z - v3Extents.z);
			float t = 0;
			for(int i=0; i<9; i++){
				t = -Vector3.Dot(projected[i],n)/n.sqrMagnitude;
				projected[i] = n*t + projected[i];
			}
			return projected;
		}

		private Vector3[] boxVert = new Vector3[17];

		void CalcPositons(Bounds b, Transform t,Vessel v){
			
			Vector3 v3Center = b.center;
			Vector3 v3Extents = b.extents;
			
			Vector3 v3FTL = new Vector3(v3Center.x - v3Extents.x, v3Center.y + v3Extents.y, v3Center.z - v3Extents.z);
			Vector3 v3FTR = new Vector3(v3Center.x + v3Extents.x, v3Center.y + v3Extents.y, v3Center.z - v3Extents.z);
			Vector3 v3FBL = b.min;
			Vector3 v3FBR = new Vector3(v3Center.x + v3Extents.x, v3Center.y - v3Extents.y, v3Center.z - v3Extents.z);
			Vector3 v3BTL = new Vector3(v3Center.x - v3Extents.x, v3Center.y + v3Extents.y, v3Center.z + v3Extents.z);
			Vector3 v3BTR = b.max;
			Vector3 v3BBL = new Vector3(v3Center.x - v3Extents.x, v3Center.y - v3Extents.y, v3Center.z + v3Extents.z);
			Vector3 v3BBR = new Vector3(v3Center.x + v3Extents.x, v3Center.y - v3Extents.y, v3Center.z + v3Extents.z);
			
			boxVert[0]  = v3FTL; boxVert[1]  = v3FTR; boxVert[2]  = v3FBR; boxVert[3]  = v3FBL; boxVert[4]  = v3FTL;
			boxVert[5]  = v3BTL; boxVert[6]  = v3BTR; boxVert[7]  = v3FTR; boxVert[8]  = v3FBR; boxVert[9]  = v3BBR;
			boxVert[10] = v3BTR; boxVert[11] = v3BTL; boxVert[12] = v3BBL; boxVert[13] = v3FBL; boxVert[14] = v3FBR;
			boxVert[15] = v3BBR; boxVert[16] = v3BBL;
			
			for(int i=0; i<17; i++)
				boxVert[i] = v.vesselTransform.InverseTransformPoint(t.TransformPoint(boxVert[i]));
		}

		/*public virtual void UpdatePanelExtended ()
		{
			Vector3 normalized = (this.?.position - this.?.position).normalized;
			Ray ray = new Ray (ScaledSpace.LocalToScaledSpace(this.?.position + normalized * 1f),
			                   (ScaledSpace.LocalToScaledSpace (this.?.position) - 
			 					ScaledSpace.LocalToScaledSpace (this.?.position)).normalized);
			string str = string.Empty;
			float distance = 3.40282347E+38f;
			bool flag;
			if (Physics.Raycast (ray, out this.hit, distance, this.?))
			{
				str = this.hit.transform.gameObject.name;
				flag = false;
			}
			else
			{
				ray = new Ray (this.?.position + normalized * 2f, this.?.position - this.?.position);
				if (Physics.Raycast (ray, out this.hit, distance, this.?))
				{
					if (this.hit.transform.gameObject.GetComponent<PQ> ())
						str = . (125566);
					else
						str = this.hit.transform.gameObject.name;
					flag = false;
				}
				else
					flag = true;
			}
			if (flag)
			{
				this.status = . (139461);
				this.sunAOA = Mathf.Clamp (Vector3.Dot (this.?.forward, normalized), 0f, 1f);
			}
			else
			{
				this.status = . (139492) + str;
				this.sunAOA = 0f;
			}
			if (this.sunTracking)
			{
				if (flag)
				{
					Vector3 vector = this.?.InverseTransformPoint (this.?.position);
					float y = Mathf.Atan2 (vector.x, vector.z) * 57.29578f;
					Quaternion to = this.?.rotation * Quaternion.Euler (0f, y, 0f);
					this.?.rotation = Quaternion.Lerp (this.?.rotation, to, TimeWarp.deltaTime * this.trackingSpeed);
				}
			}
			this.SetDragCubes (0f, Mathf.Abs (Mathf.Sin (0.0174532924f * this.	
			                                             .rotation.eulerAngles.y)));
			this.UpdatePanelExtended_SetResource ();
		}*/

	}
}

